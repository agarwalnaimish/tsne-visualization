<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>t-SNE Visualizer</title>

<script src="jquery-1.8.3.min.js"></script>
<script src="tsne.js"></script>
<script src="fpsmeter.min.js"></script>
<script src="three.min.js"></script>
<script src="TrackballControls.js"></script>
<link href='http://fonts.googleapis.com/css?family=Roboto:400,300' rel='stylesheet' type='text/css'>

<style>
body {
  font-family: 'Roboto', sans-serif;
  color: #333;
  font-weight: 300;
  font-size: 16px;
}
svg {
  border: 1px solid #333;
}
#wrap {
  width: 80%;
  margin-left: auto;
  margin-right: auto;
}
#container {
  margin-top: 10px;
}
h1 {
  text-align: center;
  font-weight: normal;
}
.tt {
  margin-top: 10px;
  background-color: #EEE;
  border-bottom: 1px solid #333;
  padding: 5px;
}
.txth {
  color: #F55;
}
.cit {
  font-family: courier;
  padding-left: 20px;
  font-size: 14px;
}
</style>

<script>
(function() {
  "use strict";

  var T, reducedPoints;
  var data;
  var config;
  var fpsMeter;

	var camera, scene, renderer, controls;
	var clock = new THREE.Clock();
	var sprites = [];

  function updateEmbedding() {
		for (var i = 0; i < sprites.length; i++) {
			var x = reducedPoints[i][0] * config.spreadFactor;
			var y = reducedPoints[i][1] * config.spreadFactor;
			var z = config.enable3D ? reducedPoints[i][2] * config.spreadFactor : 0;
			sprites[i].position.set(x, y, z);
		}
  }

  function init() {
		// Init scene, renderer
    scene = new THREE.Scene();  
    renderer = new THREE.WebGLRenderer();
    renderer.setSize(config.embedWindowX, config.embedWindowY);
    renderer.setClearColor(0xDDDDDD, 1);
    renderer.clear();
     
    // Attach renderer to DOM element
    var container = document.getElementById('container');
    container.appendChild(renderer.domElement);
     
    // Camera
    // If points disappear in the distance, then increase FAR
    var viewAngle = 45, 
        aspect = config.embedWindowX / config.embedWindowY, 
        near = 0.1, far = 100000;
    camera = new THREE.PerspectiveCamera(viewAngle, aspect, near, far);
    camera.position.set(0, 0, config.cameraZ || 300);
    scene.add(camera); 
     
    // Controls
    controls = new THREE.TrackballControls(camera, renderer.domElement);
		controls.target.set(0, 0, 0);

		// Create objects
		createObjects();
  }

	function createObjects() {
		var labelToColorMap = getColorPalette();

		for (var i=0; i < data.labels.length; i++) {
			var sprite = makeSprite(data.labels[i], "data/" + data.images[i], labelToColorMap[data.labels[i]]);
			sprites.push(sprite);
			scene.add(sprite);
		}
	}	

	// Creates a unique color per label
	function getColorPalette() {
		var labelMap = {};
		for (var i = 0; i < data.labels.length; i++) {
			labelMap[data.labels[i]] = 1 + (labelMap[data.labels[i]] || 0);
		}

    var hue = 0;
    var saturation = 70;
    var lightness = 45;
    var size = Object.keys(labelMap).length;
		var i = 0;
		for (var label in labelMap) {
		  if (!labelMap.hasOwnProperty(label)) {		   
		      continue;
		  }
			
      hue = ((i + 1) * 360) / size;
			i++;
			labelMap[label] = "hsl(" + hue + ", " + saturation + "%, " + lightness + "%";
    }
		return labelMap;		
	}

	// Makes a sprite by using a canvas as a texture.
	function makeSprite(label, imagePath, color) {
		var canvas = document.createElement('canvas');
		var texture = new THREE.Texture(canvas)

		var ctx = canvas.getContext('2d');
		canvas.width = config.thumbImgSize;
		canvas.height = config.thumbImgSize;

		var image = new Image();
		image.onload = function() {
			// Scale image to fit
			ctx.drawImage(image, 0, 0, image.width, image.height, 
												   0, 20, config.thumbImgSize, config.thumbImgSize);

			// Black text on BG color.
			ctx.fillStyle = "#DDDDDD";
			ctx.fillRect(0, 0, config.thumbImgSize, 20);
			
			// Draw label.
			var rectBorderWidth = 0.1 * config.thumbImgSize;	// 10% of image size
			ctx.fillStyle = "black";
			ctx.fillText(label, rectBorderWidth, 15);

			// Rect border indicating label cluster
			ctx.strokeStyle = color;
			ctx.lineWidth = rectBorderWidth;
			ctx.strokeRect(0, 0, config.thumbImgSize, config.thumbImgSize);

			// Flag for update
			texture.needsUpdate = true;
		};
		image.src = imagePath;

		var spriteMaterial = new THREE.SpriteMaterial({
			map: texture
		});

		var sprite = new THREE.Sprite(spriteMaterial);
		sprite.scale.set(config.thumbImgSize, config.thumbImgSize, 1.0)
		return sprite;
	}
	
	function animate() {
    requestAnimationFrame(animate);
		var delta = clock.getDelta(); 
		step();
    controls.update(delta); 
    renderer.render(scene, camera);
	}

  function step() {
    fpsMeter.tickStart();

    T.step();
    reducedPoints = T.getSolution();
    updateEmbedding();
    
    fpsMeter.tick();
  }

  $(window).load(function() {
    fpsMeter = new FPSMeter();

    $.getJSON("config.json", function(configJson) {
      config = configJson
      T = new tsnejs.tSNE({
        epsilon: config.epsilon, 
        perplexity: config.perplexity,
				dim: config.enable3D ? 3 : 2
      });

      $.getJSON("data/data.json", function(dataJson) {
        data = dataJson;

    	  // Trim dataset to limit
				if (config.limit !== -1) {
    		  var len = Math.min(config.limit, data.labels.length)
    	    data.labels.length = len
    	    data.weights.length = len
				  if (data.images) {
    		    data.images.length = len
    	    }
   	   	}

				// Create initial objects and animate
    	  T.initDataDist(data.weights); 
   	    init(); 
				animate();
      });
    });
  });

})();

</script>

</head>

<body>
<div id="wrap">
<h1>t-SNE Visualization Utility</h1>
<div class="sec">
  t-SNE is a visualization algorithm that embeds things in 2 or 3 dimensions according to some desired distances. If you have some data and you can measure their pairwise differences, t-SNE visualization can help you identify various clusters. This visualizer uses <a href="https://github.com/karpathy/tsnejs">tSNEJS</a> from kaparthy to compute lower dimensional embeddings.

  <br><br> <span class="txth">Go ahead, pan and zoom around with mouse!</span>
  <br> (Note that can take a while to load all images...)
</div>

<div id="container"></div>
<br>

<div class="tt">Algorithm Details</div>
<div class="sec">
  The algorithm is described in this paper:

  <div class="cit">
  <br>L.J.P. van der Maaten and G.E. Hinton. 
  <br>Visualizing High-Dimensional Data Using t-SNE. Journal of Machine Learning Research 9(Nov):2579-2605, 2008. 
  <br><a href="http://jmlr.csail.mit.edu/papers/volume9/vandermaaten08a/vandermaaten08a.pdf">[PDF]</a> <a href="http://jmlr.csail.mit.edu/papers/volume9/vandermaaten08a/vandermaaten08a-supplement.pdf">[Supplemental Material (24MB)]</a>
  </div>

  <br>
  In short, the algorithm computes a matrix P that is related to distances between all elements in the original space. The variables of the problem are the embedding point locations, which similarily rise to their own distance matrix Q. The algorithm's cost function then minimizes the difference between P and Q. 
</div>
<br><br>
</body>

</html>
