<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>t-SNE Visualizer</title>

<script src="jquery-1.8.3.min.js"></script>
<script src="tsne.js"></script>
<script src="fpsmeter.min.js"></script>
<script src="three.min.js"></script>
<script src="TrackballControls.js"></script>
<script src="palette.js"></script>
<link href='http://fonts.googleapis.com/css?family=Roboto:400,300' rel='stylesheet' type='text/css'>

<style>
body {
  font-family: 'Roboto', sans-serif;
  color: #333;
  font-weight: 300;
  font-size: 16px;
}
svg {
  border: 1px solid #333;
}
#wrap {
  width: 80%;
  margin-left: auto;
  margin-right: auto;
}
#container {
  margin-top: 10px;
}
h1 {
  text-align: center;
  font-weight: normal;
}
.tt {
  margin-top: 10px;
  background-color: #EEE;
  border-bottom: 1px solid #333;
  padding: 5px;
}
.txth {
  color: #F55;
}
.cit {
  font-family: courier;
  padding-left: 20px;
  font-size: 14px;
}
</style>

<script>
(function() {
  "use strict";

  var T, reducedPoints;
  var data;
  var config;
  var fpsMeter;

	var camera, scene, renderer, controls;
	var clock = new THREE.Clock();
	var imageSprites = [];
	var labelSprites = [];

  function updateEmbedding() {
		for (var i = 0; i < labelSprites.length; i++) {
			var x = reducedPoints[i][0] * config.spreadFactor;
			var y = reducedPoints[i][1] * config.spreadFactor;
			var z = config.enable3D ? reducedPoints[i][2] * config.spreadFactor : 0;

			imageSprites[i].position.set(x, y, z);
			labelSprites[i].position.set(x, y + config.thumbImgSize / 2, z);
		}
  }

  function init() {
		// Init scene, renderer
    scene = new THREE.Scene();  
    renderer = new THREE.WebGLRenderer();
    renderer.setSize(config.embedWindowX, config.embedWindowY);
    renderer.setClearColor(0xDDDDDD, 1);
    renderer.clear();
     
    // Attach renderer to DOM element
    var container = document.getElementById('container');
    container.appendChild(renderer.domElement);
     
    // Camera
    // If points disappear in the distance, then increase FAR
    var viewAngle = 45, 
        aspect = config.embedWindowX / config.embedWindowY, 
        near = 0.1, far = 100000;
    camera = new THREE.PerspectiveCamera(viewAngle, aspect, near, far);
    camera.position.set(0, 0, 500);
    scene.add(camera); 
     
    // Controls
    controls = new THREE.TrackballControls(camera, renderer.domElement);
		controls.target.set(0, 0, 0);

		// Create objects
		createObjects();
  }

	function createObjects() {
		for (var i=0; i < data.labels.length; i++) {
			var imageSprite = makeImageSprite("data/" + data.images[i]);
			imageSprites.push(imageSprite);

			var labelSprite = makeTextSprite(data.labels[i]);
			labelSprites.push(labelSprite);

			scene.add(imageSprite);
			scene.add(labelSprite);
		}
	}

	function makeImageSprite(imagePath) {
		var material = new THREE.SpriteMaterial({
			map: THREE.ImageUtils.loadTexture(imagePath)
		});

		var sprite = new THREE.Sprite(material);	
		sprite.scale.set(config.thumbImgSize, config.thumbImgSize, 1.0);
		return sprite;		
	}

	function makeTextSprite(label)
	{
		var canvas = document.createElement('canvas');
		var context = canvas.getContext('2d');
		context.font = "Bold 12 px Courier";
		  
		// get size data (height depends only on font size)
		var textWidth = context.measureText(label).width;	

		// text color
		context.fillStyle = "rgba(0, 0, 0, 1.0)";
		context.fillText(label, 0, 12);
	
		// canvas contents will be used for a texture
		var texture = new THREE.Texture(canvas) 
		texture.needsUpdate = true;

		var spriteMaterial = new THREE.SpriteMaterial({
			map: texture
		});

		var sprite = new THREE.Sprite(spriteMaterial);
		sprite.position.set(0, config.thumbImageSize / 2, 0);		
		return sprite;
	}

	function animate() {
    requestAnimationFrame(animate);
		var delta = clock.getDelta(); 
		step();
    controls.update(delta); 
    renderer.render(scene, camera);
	}

  function step() {
    fpsMeter.tickStart();

    T.step();
    reducedPoints = T.getSolution();
    updateEmbedding();
    
    fpsMeter.tick();
  }

  $(window).load(function() {
    fpsMeter = new FPSMeter();

    $.getJSON("config.json", function(configJson) {
      config = configJson
      T = new tsnejs.tSNE({
        epsilon: config.epsilon, 
        perplexity: config.perplexity,
				dim: config.enable3D ? 3 : 2
      });

      $.getJSON("data/data.json", function(dataJson) {
        data = dataJson;

    	  // Trim dataset to limit
				if (config.limit !== -1) {
    		  var len = Math.min(config.limit, data.labels.length)
    	    data.labels.length = len
    	    data.weights.length = len
				  if (data.images) {
    		    data.images.length = len
    	    }
   	   	}

				// Create initial objects and animate
    	  T.initDataDist(data.weights); 
   	    init(); 
				animate();
      });
    });
  });

})();

</script>

</head>

<body>
<div id="wrap">
<h1>t-SNE Visualization Utility</h1>
<div class="sec">
  t-SNE is a visualization algorithm that embeds things in 2 or 3 dimensions according to some desired distances. If you have some data and you can measure their pairwise differences, t-SNE visualization can help you identify various clusters. This visualizer uses <a href="https://github.com/karpathy/tsnejs">tSNEJS</a> from kaparthy to compute lower dimensional embeddings.

  <br><br> <span class="txth">Go ahead, pan and zoom around with mouse!</span>
  <br> (Note that can take a while to load all images...)
</div>

<div id="container"></div>
<br>

<div class="tt">Algorithm Details</div>
<div class="sec">
  The algorithm is described in this paper:

  <div class="cit">
  <br>L.J.P. van der Maaten and G.E. Hinton. 
  <br>Visualizing High-Dimensional Data Using t-SNE. Journal of Machine Learning Research 9(Nov):2579-2605, 2008. 
  <br><a href="http://jmlr.csail.mit.edu/papers/volume9/vandermaaten08a/vandermaaten08a.pdf">[PDF]</a> <a href="http://jmlr.csail.mit.edu/papers/volume9/vandermaaten08a/vandermaaten08a-supplement.pdf">[Supplemental Material (24MB)]</a>
  </div>

  <br>
  In short, the algorithm computes a matrix P that is related to distances between all elements in the original space. The variables of the problem are the embedding point locations, which similarily rise to their own distance matrix Q. The algorithm's cost function then minimizes the difference between P and Q. 
</div>
<br><br>
</body>

</html>
